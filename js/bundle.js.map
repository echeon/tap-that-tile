{"version":3,"sources":["webpack:///webpack/bootstrap 0f9aa334a3b1e33d7fd9","webpack:///./js/main.js","webpack:///./js/tile.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;;AAGA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA,EAAC;;AAED;AACA,kBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;;AAEA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;;AAEA;AACA,kBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACjLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA","file":"./js/bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 0f9aa334a3b1e33d7fd9\n **/","const Tile = require('./tile.js');\n\nconst canvas = document.getElementById('canvas');\nconst ctx = canvas.getContext('2d');\n\nlet prevIndex = null;\nlet nextIndex = getNextIndex();\n\nconst FPS = 40;\n\nconst tiles = [];\n\n\n$('#canvas').on('click', e => {\n  const positionX = e.offsetX;\n\n  if (positionX >= 0 && positionX < 100) {\n    handleTap(0);\n  } else if (positionX >= 101 && positionX < 201) {\n    handleTap(1);\n  } else if (positionX >= 202 && positionX < 302) {\n    handleTap(2);\n  } else {\n    handleTap(3);\n  }\n});\n\n$(window).on('keydown', e => {\n  const key = e.key;\n\n  if (key === \"d\") {\n    handleTap(0);\n  } else if (key === \"f\") {\n    handleTap(1);\n  } else if (key === \"j\") {\n    handleTap(2);\n  } else if (key === \"k\") {\n    handleTap(3);\n  }\n});\n\nfunction handleTap(lineNumber) {\n  for (let i = 0; i < tiles.length; i++) {\n    if (!tiles[i][lineNumber].tapped) {\n      tiles[i].forEach(tile => tile.handleTap());\n      tiles[i][lineNumber].changeColor();\n      if (!tiles[i][lineNumber].isBlack) {\n        draw();\n        update();\n        window.clearInterval(updateId);\n        window.clearInterval(addRowId);\n        $('#canvas').off('click');\n        $(window).off('keydown');\n      }\n      break;\n    }\n  }\n}\n\nfunction generateRow() {\n  const nextRow = [];\n  [0, 1, 2, 3].forEach(lineIndex => {\n    if (lineIndex === nextIndex) {\n      nextRow.push(new Tile(canvas, true, lineIndex));\n    } else {\n      nextRow.push(new Tile(canvas, false, lineIndex));\n    }\n  });\n\n  prevIndex = nextIndex;\n  nextIndex = getNextIndex();\n\n  return nextRow;\n}\n\nfunction getNextIndex() {\n  let nextIndex = Math.floor(Math.random() * 4);\n  while (nextIndex === prevIndex) {\n    nextIndex = Math.floor(Math.random() * 4);\n  }\n  return nextIndex;\n}\n\n\nconst updateId = window.setInterval(() => {\n  if (isGameOver()) {\n    window.clearInterval(updateId);\n    window.clearInterval(addRowId);\n    $('#canvas').off('click');\n    $(window).off('keydown');\n    handleGameOver();\n  }\n  draw();\n  update();\n}, 10);\n\nfunction handleGameOver() {\n  changeMissedTileColor();\n  moveEverythingUp();\n}\n\nfunction changeMissedTileColor() {\n  tiles[0].forEach(tile => {\n    if (tile.isBlack) {\n      tile.changeColorToRed();\n    }\n  })\n}\n\nfunction moveEverythingUp() {\n  tiles.forEach(row => {\n    row.forEach(tile => {\n      tile.moveUp();\n    });\n  });\n}\n\nfunction printLocation() {\n  console.log(tiles.map(row => {\n    return row.map(tile => tile.coordY);\n  }));\n}\n\nconst addRowId = window.setInterval(() => {\n  addRow();\n}, (10)*(150/10));\n\nfunction draw() {\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  drawDividers();\n  tiles.forEach(row => {\n    row.forEach(tile => {\n      tile.draw();\n    });\n  });\n}\n\nfunction update() {\n  tiles.forEach(row => {\n    row.forEach(tile => {\n      tile.update();\n    });\n  });\n}\n\nfunction isGameOver() {\n  for (let i = 0; i < tiles.length; i++) {\n    const nextUntappedTile = tiles[i][0];\n    if (!nextUntappedTile.tapped && nextUntappedTile.coordY >= 600) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction addRow() {\n  const newRow = generateRow()\n  tiles.push(newRow);\n  if (tiles.length >= 7) {\n    tiles.shift();\n  }\n}\n\nfunction drawDividers() {\n  ctx.strokeStyle = '#fff';\n  ctx.lineWidth = 1;\n  ctx.beginPath();\n  ctx.moveTo(100.5, 0);\n  ctx.lineTo(100.5, 600);\n  ctx.stroke();\n  ctx.moveTo(201.5, 0);\n  ctx.lineTo(201.5, 600);\n  ctx.stroke();\n  ctx.moveTo(302.5, 0);\n  ctx.lineTo(302.5, 600);\n  ctx.stroke();\n  ctx.closePath();\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./js/main.js\n ** module id = 0\n ** module chunks = 0\n **/","class Tile {\n  constructor(canvas, isBlack, lineNumber) {\n    this.canvas = canvas;\n    this.ctx = canvas.getContext('2d');\n    this.tapped = false;\n    this.isBlack = isBlack;\n    this.color = isBlack ? \"#000\" : \"transparent\";\n    this.coordX = 101 * lineNumber;\n    this.coordY = -150;\n  }\n\n  draw() {\n    const tileWidth = 100;\n    const tileHeight = 150;\n\n    this.ctx.fillStyle = this.color;\n    this.ctx.fillRect(this.coordX, this.coordY, tileWidth, tileHeight);\n  }\n\n  update() {\n    this.coordY += 10;\n  }\n\n  handleTap() {\n    this.tapped = !this.tapped;\n  }\n\n  changeColor() {\n    const tappedBlack = \"rgba(0, 0, 0, 0.1)\";\n    const tappedWrong = \"rgba(255, 50, 50, 1)\";\n    this.color = (this.color === \"#000\") ? tappedBlack : tappedWrong;\n  }\n\n  changeColorToRed() {\n    this.color = \"rgb(255, 50, 50)\";\n  }\n\n  moveUp() {\n    this.coordY -= 150;\n  }\n}\n\n\nmodule.exports = Tile;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./js/tile.js\n ** module id = 1\n ** module chunks = 0\n **/"],"sourceRoot":""}